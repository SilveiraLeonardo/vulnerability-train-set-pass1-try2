
const express = require('express');
const router = express.Router();
const ping = require('ping');
const { execFile, spawn } = require('child_process');
const path = require('path');

router.post('/ping', (req, res) => {
    const host = req.body.url; // Consider using a URL parsing library to extract the hostname from the URL
    if (!host) {
        return res.send('error');
    }

    ping.promise.probe(host)
        .then((result) => {
            if (result.alive) {
                res.send('pong');
            } else {
                res.send('error');
            }
        })
        .catch((error) => {
            // Handle error case (e.g. DNS resolution failed)
            res.send('error');
        });
});

router.post('/gzip', (req, res) => {
    const filePath = req.query.file_path;
    if (!filePath || !path.isAbsolute(filePath)) {
        return res.status(400).send('Invalid file path');
    }

    // You should implement additional checks to control which folders/files the user can access.

    execFile('gzip', [filePath], (err, data) => {
        if (err) {
            console.log('err: ', err);
            return res.status(500).send('Error');
        }
        console.log('data: ', data);
        res.send('done');
    });
});

router.get('/run', (req, res) => {
    let cmd = req.params.cmd;

    if (!cmd) {
        return res.status(400).send('No command specified');
    }

    // You should add a list of allowed commands and check if the command is allowed before running it.

    const allowedCommands = ['command1', 'command2', 'command3'];
    if (!allowedCommands.includes(cmd)) {
        return res.status(403).send('Forbidden command');
    }

    runMe(cmd, res);
});

function runMe(cmd, res) {
    const cmdRunning = spawn(cmd, []);
    cmdRunning.on('close', (code) => {
        res.send(`child process exited with code ${code}`);
    });
}

module.exports = router;
